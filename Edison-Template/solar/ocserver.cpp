//******************************************************************
//
// Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


#include <stdio.h>
#include <string.h>
#include <string>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#include <array>
#include <sstream>
#include <mraa.h>
#include "ocstack.h"
#include "logger.h"
#include "ocpayload.h"
#include "ocserver.h"


#include "mraa.h"
#include "jhd1313m1.h"


const int URI_MAXSIZE = 19;

static int gObserveNotifyType = 3;
const char *getResult(OCStackResult result);


mraa_pwm_context pwm;

upm::Jhd1313m1 *lcd;



int gQuitFlag = 0;
int gIOT_UnderObservation = 0;
static int IOTsleep;
///----------------------------User Defined function------------------------------------------
float map(double x, float in_min, float in_max, float out_min, float out_max)
{
   

  return (float)(x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}




typedef struct IOT_SOURCE
{
    OCResourceHandle handle;    //handle
    bool hasUpdate; // need for state monator
    char* Type;     // need for node Rools
    //// User Defined props /////
    double tiltPercentage; 
    const char* lcd1;
    const char* lcd2;

} IOT_Resource;

static IOT_Resource IOT_;       //globle Resource used to mange the device data


bool onoff;


char *gResourceUri= (char *)"/a/solar";       // the URI of the Resource



//// the mane setup function, called once at power on and on reset. ///////
void IOT_Setup(){ 
    lcd = new upm::Jhd1313m1(0, 0x3E, 0x62);

    lcd->setCursor(0,0);
    lcd->write("Solar");
    lcd->setCursor(1,0);
    lcd->write("IOT Tracker");
    lcd->setColor(255,0,0);

    IOT_.hasUpdate = true;          // will send new data to IOT
    IOT_.Type = (char *)"solar";   // Sets the Type for Ruls
    IOT_.lcd1 = (char *)"Solar Conected!!";
    IOT_.lcd2 = (char *)"IOT Tracker";

    IOTsleep = 3;
    pwm = mraa_pwm_init(3);
    if (pwm != NULL) {
        mraa_pwm_period_ms(pwm, 20);
        mraa_pwm_enable(pwm, 1);   
    
        mraa_pwm_write(pwm, .05);
        printf("%s\n", "mraa_pwm_enable Setup\n");
    }
    

}


float value = 0.0f;
float min = 0.033, max = 0.166;

// the Maine loop function, called eavery IOTsleep secs,
void IOT_Loop(){

    //IOT_.hasUpdate = true;  // will send new data to IOT
    //value = value + 1.0f;
    //mraa_pwm_write(pwm, );
}



// the function for consterecting the Resource payload
OCRepPayload* sendPayload()
{
    OCRepPayload* payload = OCRepPayloadCreate();
    OCRepPayload* att_payload = OCRepPayloadCreate();
    if(!payload)
    {
        printf(PCF("Failed to allocate Payload\n"));
        return nullptr;
    }

    OCRepPayloadSetUri(payload, gResourceUri);
    
    OCRepPayloadSetPropDouble(att_payload, "tiltPercentage", IOT_.tiltPercentage);
    OCRepPayloadSetPropString(att_payload, "lcd1", IOT_.lcd1);
    OCRepPayloadSetPropString(att_payload, "lcd2", IOT_.lcd2);

    OCRepPayloadSetPropObject(payload, "ATT", att_payload);

    OCRepPayloadSetPropString(payload, "Type", IOT_.Type);


    return payload;
}

// the function for parcing the incoming Resource payload
void recivedPayload(OCRepPayload* input){


    double pos;
    if(OCRepPayloadGetPropDouble(input, "tiltPercentage", &pos))
    {
        IOT_.tiltPercentage = pos;
       

        if (pwm != NULL) {
            
            float val  = map(pos, 0, 100, .05, .10);

             printf("%s %g : %g \n", "tiltPercentage: ",pos, val);

            mraa_pwm_write(pwm, val);

        }
        IOT_.hasUpdate = true;
    }else{
        printf(PCF("Failed to allocate tiltPercentage\n"));
    }
    

    const char * str;

    if(OCRepPayloadGetPropString(input, "lcd1" ,&str)){
        IOT_.lcd1 = str;
        lcd->setCursor(0,0);
        lcd->write(IOT_.lcd1);
    }

    if(OCRepPayloadGetPropString(input, "lcd2" ,&str)){
        lcd->setCursor(1,0);
        lcd->write(str);
    }



}




//--------------all fucntion below are autogenerated and will be repalce on compile ----------------------------
//--------------------------------------------------------------------------------------------------------------



int createIOT_Resource (char *uri, IOT_Resource *IOT_Resource);


Observers interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];




const char *dateOfManufacture = "myDateOfManufacture";
const char *deviceName = "myDeviceName";
const char *deviceUUID = "myDeviceUUID";
const char *firmwareVersion = "myFirmwareVersion";
const char *manufacturerName = "myName";
const char *operatingSystemVersion = "myOS";
const char *hardwareVersion = "myHardwareVersion";
const char* platformID = "myPlatformID";
const char *manufacturerUrl = "myManufacturerUrl";
const char *modelNumber = "myModelNumber";
const char *platformVersion = "myPlatformVersion";
const char *supportUrl = "mySupportUrl";
const char *version = "myVersion";
const char *systemTime = "2015-05-15T11.04";

// Entity handler should check for resourceTypeName and ResourceInterface in order to GET
// the existence of a known resource
const char *resourceTypeName = "core.IOT_";
const char *resourceInterface = OC_RSRVD_INTERFACE_DEFAULT;

OCPlatformInfo platformInfo;
OCDeviceInfo deviceInfo;




OCRepPayload* constructResponse(OCEntityHandlerRequest *ehRequest){


    if(ehRequest->payload && ehRequest->payload->type != PAYLOAD_TYPE_REPRESENTATION)
    {
        printf(PCF("Incoming payload not a representation\n"));
        return nullptr;
    }
    OCRepPayload* input = reinterpret_cast<OCRepPayload*>(ehRequest->payload);

    if(OC_REST_PUT == ehRequest->method)
    {
        recivedPayload(input);
    }
    
    return sendPayload();
}

/*
 * Application should validate and process these as desired.
 */
OCEntityHandlerResult ValidateQueryParams (OCEntityHandlerRequest *entityHandlerRequest)
{
    printf(PCF("Received query %s\n"), entityHandlerRequest->query);
    printf(PCF("Not processing query\n"));
    return OC_EH_OK;
}

OCEntityHandlerResult ProcessGetRequest (OCEntityHandlerRequest *ehRequest,
        OCRepPayload **payload)
{
    OCEntityHandlerResult ehResult;
    OCRepPayload *getResp = constructResponse(ehRequest);

    if(!getResp)
    {
        printf("Failed to construct Json response\n");
        return OC_EH_ERROR;
    }

    *payload = getResp;
    ehResult = OC_EH_OK;

    return ehResult;
}

OCEntityHandlerResult ProcessPutRequest (OCEntityHandlerRequest *ehRequest,
        OCRepPayload** payload)
{
    OCEntityHandlerResult ehResult;
    OCRepPayload *putResp = constructResponse(ehRequest);

    if(!putResp)
    {
        printf("Failed to construct Json response\n");
        return OC_EH_ERROR;
    }

    *payload = putResp;
    ehResult = OC_EH_OK;

    return ehResult;
}


OCEntityHandlerResult ProcessDeleteRequest (OCEntityHandlerRequest *ehRequest)
{
    if(ehRequest == NULL)
    {
        printf("The ehRequest is NULL\n");
        return OC_EH_ERROR;
    }
    OCEntityHandlerResult ehResult = OC_EH_OK;

    printf("\n\nExecuting %s for resource %d \n", __func__, ehRequest->resource);

    /*
     * In the sample below, the application will:
     * 1a. pass the delete request to the c stack
     * 1b. internally, the c stack figures out what needs to be done and does it accordingly
     *    (e.g. send observers notification, remove observers...)
     * 1c. the c stack returns with the result whether the request is fullfilled.
     * 2. optionally, app removes observers out of its array 'interestedObservers'
     */

    if ((ehRequest != NULL) && (ehRequest->resource == IOT_.handle))
    {
        //Step 1: Ask stack to do the work.
        OCStackResult result = OCDeleteResource(ehRequest->resource);

        if (result == OC_STACK_OK)
        {
            printf("\n\nDelete Resource operation succeeded.\n");
            ehResult = OC_EH_OK;

            //Step 2: clear observers who wanted to observe this resource at the app level.
            for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
            {
                if (interestedObservers[i].resourceHandle == ehRequest->resource)
                {
                    interestedObservers[i].valid = false;
                    interestedObservers[i].observationId = 0;
                    interestedObservers[i].resourceHandle = NULL;
                }
            }
        }
        else if (result == OC_STACK_NO_RESOURCE)
        {
            printf("\n\nThe resource doesn't exist or it might have been deleted.\n");
            ehResult = OC_EH_RESOURCE_DELETED;
        }
        else
        {
            printf("\n\nEncountered error from OCDeleteResource().\n");
            ehResult = OC_EH_ERROR;
        }
    }
    else if (ehRequest->resource != IOT_.handle)
    {
        //Let's this app not supporting DELETE on some resources so
        //consider the DELETE request is received for a non-support resource.
        printf("\n\nThe request is received for a non-support resource.\n");
        ehResult = OC_EH_FORBIDDEN;
    }

    return ehResult;
}

OCEntityHandlerResult ProcessNonExistingResourceRequest(OCEntityHandlerRequest *ehRequest)
{
    printf("\n\nExecuting %s ", __func__);

    return OC_EH_RESOURCE_NOT_FOUND;
}

void ProcessObserveRegister (OCEntityHandlerRequest *ehRequest)
{
    printf("Received observation registration request with observation Id %d",
            ehRequest->obsInfo.obsId);

    lcd->setColor(0,255,0);

    lcd->setCursor(0,0);
    lcd->write(IOT_.lcd1);
    lcd->setCursor(1,0);
    lcd->write(IOT_.lcd2);


    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
    {
        if (interestedObservers[i].valid == false)
        {
            interestedObservers[i].observationId = ehRequest->obsInfo.obsId;
            interestedObservers[i].valid = true;
            gIOT_UnderObservation = 1;
            break;
        }
    }
}

void ProcessObserveDeregister (OCEntityHandlerRequest *ehRequest)
{
    bool clientStillObserving = false;

   printf("Received observation deregistration request for observation Id %d",
            ehRequest->obsInfo.obsId);
    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
    {
        if (interestedObservers[i].observationId == ehRequest->obsInfo.obsId)
        {
            interestedObservers[i].valid = false;
        }
        if (interestedObservers[i].valid == true)
        {
            // Even if there is one single client observing we continue notifying entity handler
            clientStillObserving = true;
        }
    }
    if (clientStillObserving == false)
        gIOT_UnderObservation = 0;
}

OCEntityHandlerResult
OCDeviceEntityHandlerCb (OCEntityHandlerFlag flag,
        OCEntityHandlerRequest *entityHandlerRequest, char* uri, void* callbackParam)
{
    printf("Inside device default entity handler - flags: 0x%x, uri: %s", flag, uri);

    OCEntityHandlerResult ehResult = OC_EH_OK;
    OCEntityHandlerResponse response;

    // Validate pointer
    if (!entityHandlerRequest)
    {
        printf("Invalid request pointer\n");
        return OC_EH_ERROR;
    }
    // Initialize certain response fields
    response.numSendVendorSpecificHeaderOptions = 0;
    memset(response.sendVendorSpecificHeaderOptions, 0,
            sizeof response.sendVendorSpecificHeaderOptions);
    memset(response.resourceUri, 0, sizeof response.resourceUri);
    OCRepPayload* payload = nullptr;


    if (flag & OC_REQUEST_FLAG)
    {
       printf("Flag includes OC_REQUEST_FLAG\n");

        if (entityHandlerRequest->resource == NULL)
        {
            printf("Received request from client to a non-existing resource\n");
            ehResult = ProcessNonExistingResourceRequest(entityHandlerRequest);
        }
        else if (OC_REST_GET == entityHandlerRequest->method)
        {
            printf("Received OC_REST_GET from client\n");
            ehResult = ProcessGetRequest (entityHandlerRequest, &payload);
        }
        else if (OC_REST_PUT == entityHandlerRequest->method)
        {
            printf("Received OC_REST_PUT from client\n");
            ehResult = ProcessPutRequest (entityHandlerRequest, &payload);
        }
        else if (OC_REST_DELETE == entityHandlerRequest->method)
        {
            printf("Received OC_REST_DELETE from client\n");
            ehResult = ProcessDeleteRequest (entityHandlerRequest);
        }
        else
        {
            printf("Received unsupported method %d from client",
                      entityHandlerRequest->method);
            ehResult = OC_EH_ERROR;
        }
               // If the result isn't an error or forbidden, send response
        if (!((ehResult == OC_EH_ERROR) || (ehResult == OC_EH_FORBIDDEN)))
        {
            // Format the response.  Note this requires some info about the request
            response.requestHandle = entityHandlerRequest->requestHandle;
            response.resourceHandle = entityHandlerRequest->resource;
            response.ehResult = ehResult;
            response.payload = reinterpret_cast<OCPayload*>(payload);
            // Indicate that response is NOT in a persistent buffer
            response.persistentBufferFlag = 0;

            // Send the response
            if (OCDoResponse(&response) != OC_STACK_OK)
            {
                printf("Error sending response\n");
                ehResult = OC_EH_ERROR;
            }
        }
    }
    if (flag & OC_OBSERVE_FLAG)
    {
        printf("Flag includes OC_OBSERVE_FLAG\n");
        if (OC_OBSERVE_REGISTER == entityHandlerRequest->obsInfo.action)
        {
           printf("Received OC_OBSERVE_REGISTER from client\n");
        }
        else if (OC_OBSERVE_DEREGISTER == entityHandlerRequest->obsInfo.action)
        {
            printf("Received OC_OBSERVE_DEREGISTER from client\n");
        }
    }

    return ehResult;
}

OCEntityHandlerResult
OCNOPEntityHandlerCb (OCEntityHandlerFlag flag,
        OCEntityHandlerRequest *entityHandlerRequest, void* callbackParam)
{
    // This is callback is associated with the 2 presence notification
    // resources. They are non-operational.
    return OC_EH_OK;
}

OCEntityHandlerResult
OCEntityHandlerCb (OCEntityHandlerFlag flag,
        OCEntityHandlerRequest *entityHandlerRequest, void* callback)
{
   printf("Inside entity handler - flags: 0x%x", flag);

    OCEntityHandlerResult ehResult = OC_EH_OK;
    OCEntityHandlerResponse response = { 0 };

    // Validate pointer
    if (!entityHandlerRequest)
    {
       printf("Invalid request pointer\n");
        return OC_EH_ERROR;
    }

    // Initialize certain response fields
    response.numSendVendorSpecificHeaderOptions = 0;
    memset(response.sendVendorSpecificHeaderOptions,
            0, sizeof response.sendVendorSpecificHeaderOptions);
    memset(response.resourceUri, 0, sizeof response.resourceUri);
    OCRepPayload* payload = nullptr;

    if (flag & OC_REQUEST_FLAG)
    {
        //OC_LOG (INFO, TAG, "Flag includes OC_REQUEST_FLAG");

        if (OC_REST_GET == entityHandlerRequest->method)
        {
            //OC_LOG (INFO, TAG, "Received OC_REST_GET from client");
            ehResult = ProcessGetRequest (entityHandlerRequest, &payload);
        }
        else if (OC_REST_PUT == entityHandlerRequest->method)
        {
           printf("Received OC_REST_PUT from client\n");
            ehResult = ProcessPutRequest (entityHandlerRequest, &payload);
        }
        else if (OC_REST_POST == entityHandlerRequest->method)
        {
            printf("Received OC_REST_POST from client\n");
            //hResult = ProcessPostRequest (entityHandlerRequest, &response, &payload);
        }
        else if (OC_REST_DELETE == entityHandlerRequest->method)
        {
            //OC_LOG (INFO, TAG, "Received OC_REST_DELETE from client\n");
            ehResult = ProcessDeleteRequest (entityHandlerRequest);
        }
        else
        {
            printf("Received unsupported method %d from client",
                      entityHandlerRequest->method);
            ehResult = OC_EH_ERROR;
        }
        // If the result isn't an error or forbidden, send response
        if (!((ehResult == OC_EH_ERROR) || (ehResult == OC_EH_FORBIDDEN)))
        {
            // Format the response.  Note this requires some info about the request
            response.requestHandle = entityHandlerRequest->requestHandle;
            response.resourceHandle = entityHandlerRequest->resource;
            response.ehResult = ehResult;
            response.payload = reinterpret_cast<OCPayload*>(payload);
            // Indicate that response is NOT in a persistent buffer
            response.persistentBufferFlag = 0;

            // Handle vendor specific options
            if(entityHandlerRequest->rcvdVendorSpecificHeaderOptions &&
                    entityHandlerRequest->numRcvdVendorSpecificHeaderOptions)
            {
               printf("Received vendor specific options\n");
                uint8_t i = 0;
                OCHeaderOption * rcvdOptions =
                        entityHandlerRequest->rcvdVendorSpecificHeaderOptions;
                for( i = 0; i < entityHandlerRequest->numRcvdVendorSpecificHeaderOptions; i++)
                {
                    if(((OCHeaderOption)rcvdOptions[i]).protocolID == OC_COAP_ID)
                    {
                        printf("Received option with OC_COAP_ID and ID %u with",
                                ((OCHeaderOption)rcvdOptions[i]).optionID );

                        OC_LOG_BUFFER(INFO, TAG, ((OCHeaderOption)rcvdOptions[i]).optionData,
                            MAX_HEADER_OPTION_DATA_LENGTH);
                    }
                }
                OCHeaderOption * sendOptions = response.sendVendorSpecificHeaderOptions;
                uint8_t option2[] = {21,22,23,24,25,26,27,28,29,30};
                uint8_t option3[] = {31,32,33,34,35,36,37,38,39,40};
                sendOptions[0].protocolID = OC_COAP_ID;
                sendOptions[0].optionID = 2248;
                memcpy(sendOptions[0].optionData, option2, sizeof(option2));
                sendOptions[0].optionLength = 10;
                sendOptions[1].protocolID = OC_COAP_ID;
                sendOptions[1].optionID = 2600;
                memcpy(sendOptions[1].optionData, option3, sizeof(option3));
                sendOptions[1].optionLength = 10;
                response.numSendVendorSpecificHeaderOptions = 2;
            }

            // Send the response
            if (OCDoResponse(&response) != OC_STACK_OK)
            {
                printf("Error sending response\n");
                ehResult = OC_EH_ERROR;
            }
        }
    }
    if (flag & OC_OBSERVE_FLAG)
    {
        printf("Flag includes OC_OBSERVE_FLAG\n");

        if (OC_OBSERVE_REGISTER == entityHandlerRequest->obsInfo.action)
        {
            printf("Received OC_OBSERVE_REGISTER from client\n");
            ProcessObserveRegister (entityHandlerRequest);
        }
        else if (OC_OBSERVE_DEREGISTER == entityHandlerRequest->obsInfo.action)
        {
            printf("Received OC_OBSERVE_DEREGISTER from client\n");
            ProcessObserveDeregister (entityHandlerRequest);
        }
    }

    OCPayloadDestroy(response.payload);
    return ehResult;
}

/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
void handleSigInt(int signum)
{
    if (signum == SIGINT)
    {
        gQuitFlag = 1;
    }
}

void *ChangeIOT_Representation (void *param)
{
    (void)param;
    OCStackResult result = OC_STACK_ERROR;
    while (!gQuitFlag)
    {
        sleep(IOTsleep);
        
        IOT_Loop();


        if (gIOT_UnderObservation)
        {
            // Notifying all observers
            if(IOT_.hasUpdate == true){
                    IOT_.hasUpdate = false;
                printf(" =====> Notifying stack of data\n" );
                result = OCNotifyAllObservers (IOT_.handle, OC_NA_QOS);
                if (OC_STACK_NO_OBSERVERS == result)
                {
                    printf("=======> No more observers exist, stop sending observations\n");
                    gIOT_UnderObservation = 0;
                }
            }
        }
    }
    return NULL;
}


int createIOT_Resource (char *uri, IOT_Resource *IOT_Resource)
{
    if (!uri)
    {
        printf("Resource URI cannot be NULL\n");
        return -1;
    }
    OCStackResult res = OCCreateResource(&(IOT_Resource->handle),
            "core.IOT_",
            "oc.mi.def",
            uri,
            OCEntityHandlerCb,
            NULL,
            OC_DISCOVERABLE|OC_OBSERVABLE);
    printf("Created IOT_ resource with result: %s", getResult(res));

    return 0;
}

void DeletePlatformInfo()
{
    free (platformInfo.platformID);
    free (platformInfo.manufacturerName);
    free (platformInfo.manufacturerUrl);
    free (platformInfo.modelNumber);
    free (platformInfo.dateOfManufacture);
    free (platformInfo.platformVersion);
    free (platformInfo.operatingSystemVersion);
    free (platformInfo.hardwareVersion);
    free (platformInfo.firmwareVersion);
    free (platformInfo.supportUrl);
    free (platformInfo.systemTime);
}

void DeleteDeviceInfo()
{
    free (deviceInfo.deviceName);
}

bool DuplicateString(char** targetString, const char* sourceString)
{
    if(!sourceString)
    {
        return false;
    }
    else
    {
        *targetString = (char *) malloc(strlen(sourceString) + 1);

        if(*targetString)
        {
            strncpy(*targetString, sourceString, (strlen(sourceString) + 1));
            return true;
        }
    }
    return false;
}

OCStackResult SetPlatformInfo(const char* platformID, const char *manufacturerName,
    const char *manufacturerUrl, const char *modelNumber, const char *dateOfManufacture,
    const char *platformVersion, const char* operatingSystemVersion, const char* hardwareVersion,
    const char *firmwareVersion, const char* supportUrl, const char* systemTime)
{

    bool success = true;

    if(manufacturerName != NULL && (strlen(manufacturerName) > MAX_MANUFACTURER_NAME_LENGTH))
    {
        return OC_STACK_INVALID_PARAM;
    }

    if(manufacturerUrl != NULL && (strlen(manufacturerUrl) > MAX_MANUFACTURER_URL_LENGTH))
    {
        return OC_STACK_INVALID_PARAM;
    }

    if(!DuplicateString(&platformInfo.platformID, platformID))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.manufacturerName, manufacturerName))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.manufacturerUrl, manufacturerUrl))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.modelNumber, modelNumber))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.dateOfManufacture, dateOfManufacture))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.platformVersion, platformVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.operatingSystemVersion, operatingSystemVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.hardwareVersion, hardwareVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.firmwareVersion, firmwareVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.supportUrl, supportUrl))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.systemTime, systemTime))
    {
        success = false;
    }

    if(success)
    {
        return OC_STACK_OK;
    }

    DeletePlatformInfo();
    return OC_STACK_ERROR;
}

OCStackResult SetDeviceInfo(const char* deviceName)
{
    if(!DuplicateString(&deviceInfo.deviceName, deviceName))
    {
        return OC_STACK_ERROR;
    }
    return OC_STACK_OK;
}


//--------------------------------------------------------------------------------------------
//static const char * MULTICAST_RESOURCE_DISCOVERY_QUERY = "/gw/sensor/?rt=com.intel.gw";

static const char * MULTICAST_RESOURCE_DISCOVERY_QUERY = "/oic/res/?rt=core.hgw";
static OCConnectivityType OC_CONNTYPE = CT_ADAPTER_IP;
static std::string coapServerIP = "255.255.255.255";
static std::string coapServerPort = "5683";
static std::string coapServerResource = gResourceUri;

OCDoHandle gObserveDoHandle;


std::string getIPAddrTBServer(OCClientResponse * clientResponse)
{
    if (!clientResponse)
    {
        return "";
    }
    if (!clientResponse->addr)
    {
        return "";
    }


     printf("clientResponse->devAddr.addr %s",std::string(clientResponse->devAddr.addr).c_str());
    return std::string(clientResponse->devAddr.addr);
}

std::string getPortTBServer(OCClientResponse * clientResponse)
{
    if (!clientResponse)
    {
        return "";
    }
    if (!clientResponse->addr)
    {
        return "";
    }
    std::ostringstream ss;
    ss << clientResponse->devAddr.port;
    return ss.str();
}
std::string getQueryStrForGetPut(OCClientResponse * clientResponse)
{
 
    OCDiscoveryPayload* payload = (OCDiscoveryPayload*) clientResponse->payload;
    OCResourcePayload* res = payload->resources;
    int i = 1;
    std::string uri;
    
    while(res)
    {
        uri = res->uri;
        res = res->next;
        ++i;
    }
    printf("clientResponse->URI %s",uri.c_str());

    return uri.c_str();
}

std::string getConnectivityType (OCConnectivityType connType)
{
    switch (connType & CT_MASK_ADAPTER)
    {
        case CT_ADAPTER_IP:
            return "IP";

        case CT_IP_USE_V4:
            return "IPv4";

        case CT_IP_USE_V6:
            return "IPv6";

        case CT_ADAPTER_GATT_BTLE:
            return "GATT";

        case CT_ADAPTER_RFCOMM_BTEDR:
            return "RFCOMM";

        default:
            return "Incorrect connectivity";
    }
}

OCStackApplicationResult putReqCB(void* ctx, OCDoHandle handle, OCClientResponse * clientResponse)
{
    if(ctx == (void*)DEFAULT_CONTEXT_VALUE)
    {
        printf("Callback Context for PUT recvd successfully\n");
    }

    if(clientResponse)
    {
        printf("StackResult: %s",  getResult(clientResponse->result));
        OC_LOG_PAYLOAD(INFO, TAG, clientResponse->payload);
        printf(PCF("=============> Put Response"));
    }
    else
    {
        printf("putReqCB received Null clientResponse\n");
    }
    return OC_STACK_DELETE_TRANSACTION;
}


OCPayload* putPayload()
{
    OCRepPayload* payload = OCRepPayloadCreate();

    if(!payload)
    {
        printf("Failed to create put payload object\n");
        std::exit(1);
    }
    OCRepPayloadSetUri(payload, gResourceUri);
    return (OCPayload*) payload;
}




OCStackResult InvokeOCDoResource(std::ostringstream &query,
                                 OCMethod method,
                                 OCQualityOfService qos,
                                 OCClientResponseHandler cb,
                                 OCHeaderOption * options,
                                 uint8_t numOptions)
{
    OCStackResult ret;
    OCCallbackData cbData;
    OCDoHandle handle;

    cbData.cb = cb;
    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
    cbData.cd = NULL;

    ret = OCDoResource(&handle, method, query.str().c_str(), 0,
                       (method == OC_REST_PUT) ? putPayload() : NULL,
                       (OC_CONNTYPE), qos, &cbData, options, numOptions);

    if (ret != OC_STACK_OK)
    {
        printf("OCDoResource returns error %d with method %d", ret, method);
    }
    else if (method == OC_REST_OBSERVE || method == OC_REST_OBSERVE_ALL)
    {
        gObserveDoHandle = handle;
    }

    return ret;
}




int InitPutRequest(OCQualityOfService qos)
{
    printf("\n\nExecuting %s", __func__);
    std::ostringstream query;
    query << "coap://" << coapServerIP << ":" << coapServerPort << coapServerResource;

    printf("query: %s", query.str().c_str());

    return (InvokeOCDoResource(query, OC_REST_PUT, (qos == OC_HIGH_QOS)? OC_HIGH_QOS:OC_LOW_QOS,
            putReqCB, NULL, 0));
}


void parseClientResponse(OCClientResponse * clientResponse)
{
    coapServerIP = getIPAddrTBServer(clientResponse);
    coapServerPort = getPortTBServer(clientResponse);
    coapServerResource = getQueryStrForGetPut(clientResponse);
}



// This is a function called back when a device is discovered
OCStackApplicationResult discoveryReqCB(void* ctx, OCDoHandle handle,
        OCClientResponse * clientResponse)
{
    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
    {
        printf("Callback Context for DISCOVER query recvd successfully\n");
    }

    if (clientResponse)
    {
        printf("StackResult: %s", getResult(clientResponse->result));
        if(clientResponse->result == OC_STACK_OK){
            std::string connectionType = getConnectivityType (clientResponse->connType);
            printf("Discovered on %s", connectionType.c_str());
            printf(
                    "Device =============> Discovered @ %s:%d",
                    clientResponse->devAddr.addr,
                    clientResponse->devAddr.port);
            OC_LOG_PAYLOAD(INFO, TAG, clientResponse->payload);


            OC_CONNTYPE = clientResponse->connType;
            parseClientResponse(clientResponse);

            InitPutRequest(OC_LOW_QOS);
        }

    }

    return OC_STACK_KEEP_TRANSACTION;
}



int InitDiscovery(OCQualityOfService qos)
{
    OCStackResult ret;
    OCCallbackData cbData;
    /* Start a discovery query*/
    char szQueryUri[64] = { 0 };
    strcpy(szQueryUri, MULTICAST_RESOURCE_DISCOVERY_QUERY);
    

    cbData.cb = discoveryReqCB;
    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
    cbData.cd = NULL;

    ret = OCDoResource(NULL, OC_REST_DISCOVER, szQueryUri, 0, 0, OC_CONNTYPE,
                        (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS, &cbData, NULL, 0);
    
    if (ret != OC_STACK_OK)
    {
        printf("OCStack resource error\n");
    }
    return ret;
}






//--------------------------------------------------------------------------------------------

int main(int argc, char* argv[])
{
    
    IOT_Setup();


    printf("%s\n", "test1\n");
    pthread_t threadId;
    gObserveNotifyType = 0;
    #ifdef RA_ADAPTER
    OCRAInfo_t rainfo;
    rainfo.hostname = "localhost";
    rainfo.port = 5222;
    rainfo.xmpp_domain = "localhost";
    rainfo.username = "test1";
    rainfo.password = "intel123";
    rainfo.resource = "";
    rainfo.user_jid = "";

    OCSetRAInfo(&rainfo);
    #endif

    printf("%s\n","OCServer is starting...");

    if (OCInit(NULL, 0, OC_SERVER) != OC_STACK_OK)
    {
        printf("%s\n","OCStack init error");
        return 0;
    }

    OCSetDefaultDeviceEntityHandler(OCDeviceEntityHandlerCb, NULL);

    OCStackResult registrationResult =
        SetPlatformInfo(platformID, manufacturerName, manufacturerUrl, modelNumber,
            dateOfManufacture, platformVersion,  operatingSystemVersion,  hardwareVersion,
            firmwareVersion,  supportUrl, systemTime);

    if (registrationResult != OC_STACK_OK)
    {
        printf("Platform info setting failed locally!\n");
        exit (EXIT_FAILURE);
    }

    registrationResult = OCSetPlatformInfo(platformInfo);

    if (registrationResult != OC_STACK_OK)
    {
        printf("Platform Registration failed!\n");
        exit (EXIT_FAILURE);
    }

    registrationResult = SetDeviceInfo(deviceName);

    if (registrationResult != OC_STACK_OK)
    {
        printf("Device info setting failed locally!\n");
        exit (EXIT_FAILURE);
    }

    registrationResult = OCSetDeviceInfo(deviceInfo);

    if (registrationResult != OC_STACK_OK)
    {
        printf("Device Registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /*
     * Declare and create the example resource: IOT_
     */

    
    InitDiscovery(OC_LOW_QOS);


    createIOT_Resource(gResourceUri, &IOT_);

    // Initialize observations data structure for the resource
    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
    {
        interestedObservers[i].valid = false;
    }

    /*
     * Create a thread for changing the representation of the IOT_
     */
    pthread_create (&threadId, NULL, ChangeIOT_Representation, (void *)NULL);

    /*
     * Create a thread for generating changes that cause presence notifications
     * to be sent to clients
     */

     


    // Break from loop with Ctrl-C
    printf("Entering ocserver main loop...\n");

    

    DeletePlatformInfo();
    DeleteDeviceInfo();

    signal(SIGINT, handleSigInt);

    while (!gQuitFlag)
    {
        if (OCProcess() != OC_STACK_OK)
        {
            printf("OCStack process error\n");
            return 0;
        }

        //sleep(2);
    }

    /*
     * Cancel the IOT_ thread and wait for it to terminate
     */
    pthread_cancel(threadId);
    pthread_join(threadId, NULL);

    printf("Exiting ocserver main loop...\n");

    if (OCStop() != OC_STACK_OK)
    {
        printf("OCStack process error\n");
    }

    return 0;
}

const char *getResult(OCStackResult result) {
    switch (result) {
    case OC_STACK_OK:
        return "OC_STACK_OK";
    case OC_STACK_INVALID_URI:
        return "OC_STACK_INVALID_URI";
    case OC_STACK_INVALID_QUERY:
        return "OC_STACK_INVALID_QUERY";
    case OC_STACK_INVALID_IP:
        return "OC_STACK_INVALID_IP";
    case OC_STACK_INVALID_PORT:
        return "OC_STACK_INVALID_PORT";
    case OC_STACK_INVALID_CALLBACK:
        return "OC_STACK_INVALID_CALLBACK";
    case OC_STACK_INVALID_METHOD:
        return "OC_STACK_INVALID_METHOD";
    case OC_STACK_NO_MEMORY:
        return "OC_STACK_NO_MEMORY";
    case OC_STACK_COMM_ERROR:
        return "OC_STACK_COMM_ERROR";
    case OC_STACK_INVALID_PARAM:
        return "OC_STACK_INVALID_PARAM";
    case OC_STACK_NOTIMPL:
        return "OC_STACK_NOTIMPL";
    case OC_STACK_NO_RESOURCE:
        return "OC_STACK_NO_RESOURCE";
    case OC_STACK_RESOURCE_ERROR:
        return "OC_STACK_RESOURCE_ERROR";
    case OC_STACK_SLOW_RESOURCE:
        return "OC_STACK_SLOW_RESOURCE";
    case OC_STACK_NO_OBSERVERS:
        return "OC_STACK_NO_OBSERVERS";
    case OC_STACK_ERROR:
        return "OC_STACK_ERROR";
    default:
        return "UNKNOWN";
    }
}